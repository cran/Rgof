---
title: "R Package Rgof"
output: rmarkdown::html_vignette
vignette: >
  %\VignetteIndexEntry{R Package Rgof}
  %\VignetteEngine{knitr::rmarkdown}
  %\VignetteEncoding{UTF-8}
bibliography: [Rgof.bib]  
---

```{r, include = FALSE}
knitr::opts_chunk$set(
  collapse = TRUE,
  comment = "#>",
  error = TRUE
)
```

```{r setup}
library(Rgof)
```

The package *Rgof* brings together a number of routines for the goodness-of-fit problem for univariate data. We have a data set x, and we want to test whether it was generated by the probability distribution F. 

The highlights of this package are:

-  it runs a large number of different tests simultaneously.  
-  it works for continuous and for discrete (aka histogram) data.  
-  it allows for parameter estimation.    
-  it uses Rcpp and parallel programming to be very fast.  
-  it includes routines that make it very easy to estimate the power of the different tests for specific situations.  
-  it allows for the possibility that the sample size was a draw from a Poisson random variable.  
-  it allows the user to add more tests.  
-  it includes a routine to draw the usual power graph.

```{r}
set.seed(123)
```

**Note** all runs of the test routine are done with *B=1000* and all runs of the power routines with arguments *B=c(500, 500), maxProcessor = 2* in order to pass *devtools::check()*.

## The Methods 

- **Continuous Data**

1.  Kolmogorov Smirnov (KS) [@massey1951], [@kolmogorov1933], [@smirnov1948]
2.  Kuiper (K) [@kuiper1960]
3.  Anderson-Darling (AD)  [@anderson1952], [@anderson1954]
4.  Cramer-vonMises (CvM) [@anderson1962]  
5.  Wilson (W)  
6.  Zhang's methods (ZA, ZK, ZC) [@zhang2002]  
7.  Wasserstein p=1 (Wassp1)  [@wasserstein1999]

For all of these tests the distribution of the test statistic under the null hypothesis is found via simulation. 

8.  Eight variations of chi square tests, using the formulas by Pearson or based on the likelihood ratio test, bins of equal size or equal probability and both a large number and a small number of bins, 100 and 10 by default. The p values are found using the usual chi square approximation to the null distribution. If parameters are estimated this is done via the method of minimum chi square, see [@berkson1980]. In all cases bins are combined until all of them have an expected count of at least 2.

There is a very large literature on chi square tests, the oldest of the goodness of fit tests. For a survey see [@rolke2020]. 

- **Discrete (Histogram) Data**

All the methods above are also implemented for discrete data, taking advantage of the fact that the number of bins is fixed and does not grow with the sample size. Therefore the discrete versions of the tests run generally much faster than the continuous one.

It is worth noting that these discrete versions are based on the theoretical ideas of the tests and not on the actual formula of calculation for the continuous case. The test statistics can therefore be different even when applied to the same data. For example, the Anderson-Darling test is based on the distance measure

$$A^2=n\int_{-\infty}^{\infty} \frac{(\hat{F}(x)-F(x))^2}{F(x)(1-F(x))}dF(x) $$
where $F$ is the theoretical distribution function under the null hypothesis and $\hat{F}$ is the empirical distribution function. In the case of continuous data it can be shown that

$$A^2=-n-\frac1n\sum_{i=1}^n (2i-1)\left(\log F(x_i) +\log[1-F(x_{n+1-i})\right)$$
However, for discrete data we have

$$A^2=n\sum_{i=1}^k \frac{(\hat{F}(x_i)-F(x_i))^2}{F(x_i)(1-F(x_i))}\left(F(x_i)-F(x_{i-1}\right)$$

with $F(x_0)=0$. 

In the continuous case $\hat{F}$ is a step function but $F$ is continuous, and therefore $A^2>0$. In the discrete case however$A^2=0$ is possible. This shows that the two cases are fundamentally different.

As for continuous data null distributions are found using simulation. In fact in the case of discrete data none of the tests has a known distribution for the test statistic under the null hypothesis.

8.  Four variations of chi square tests, using the formulas by Pearson or based on the likelihood ratio test and both a large number and a small number of bins. Again the routine combines bins until all have expected counts greater than 2, and the chi square approximation is used to find p values.

These methods can be used for both discrete and histogram data. The main difference between these two is that discrete data has (a countable) number of possible values whereas histogram data has possible ranges of values (the bins). The only method directly affected by this difference is Wassp1, which requires actual values. All other methods ignore the *vals* argument.

## Testing

### Discrete (Histogram) Data/Model

#### Simple Null Hypothesis

We generate a data set of size 1000 from a Binomial distribution with n=20 and success probability p, and then test $H_0:F=Bin(20, 0.5)$.


```{r}
vals=0:20 #possible values of random variable
pnull=function()  pbinom(0:20, 20, 0.5)  # cumulative distribution function (cdf)
rnull = function() table(c(0:20, rbinom(1000, 20, 0.5)))-1 
# generate data under the null hypothesis, make sure that vector of counts has same length as vals, possibly 0.
```

-  **Null Hypothesis is true**

```{r}
x = rnull()
gof_test_disc(x, pnull, rnull, vals, B=1000, doMethod = "all")
```


-  **Null Hypothesis is false**

```{r d2}
x = table(c(0:20, rbinom(1000, 20, 0.55)))-1
#true p is 0.55, not 0.5
gof_test_disc(x, pnull, rnull, vals, B=1000, doMethod = "all")$p.value
```

Arguments of *gof_test_disc*:

- x: vector with counts (histogram heights). Should have a number for each value of vals, possibly 0.

-  pnull:  function to find values of cumulative distribution function for each value of vals. Function has no arguments.

-  rnull:  function to generate data from density. Function has no arguments. Function needs to insure that output is a vector with same length as vals.

-  vals: all possible values of discrete random variable, that is all x with $P(X=x)>0$

#### Random Sample Size

In some fields like high energy physics it is common that the sample size is not fixed but a random variable drawn from a Poisson distribution with a known rate. Our package easily accomodates that:

```{r r1, eval=FALSE}
rnull = function() table(c(0:20, rbinom(rpois(1, 650), 20, 0.5)))-1 
x = rnull()
gof_test_disc(x, pnull, rnull, vals, rate=650, B=1000, doMethod = "all")$p.value
```


#### Composite Null Hypothesis

We generate a data set of size 1000 from a Binomial distribution with n=20 and success probability p, and then test F=Bin(20, .). p is estimated from data.

```{r}
vals=0:20
pnull=function(p=0.5)  pbinom(0:20, 20, ifelse(p>0&&p<1, p, 0.5))  
rnull = function(p=0.5) table(c(0:20, rbinom(1000, 20, p)))-1
phat = function(x) sum(0:20*x)/sum(x)/20
```

-  **Null Hypothesis is true**

```{r ed1}
x = table(c(0:20, rbinom(1000, 20, 0.5)))-1  
gof_test_disc(x, pnull, rnull, vals, phat=phat, B=1000, doMethod = "all")$p.value
```


-  **Null Hypothesis is true**

```{r d3}
x = table(c(0:20, rbinom(1000, 20, 0.55)))-1 
# p is not 0.5, but data is still from a binomial distribution with n=20
gof_test_disc(x, pnull, rnull, vals, phat=phat, B=1000, doMethod = "all")$p.value
```

-  **Null Hypothesis is false**

```{r}
x = table(c(rep(0:20, 5), rbinom(1000-21*5, 20, 0.53))) 
# data has to many small and large values to be from a binomial
gof_test_disc(x, pnull, rnull, vals, phat=phat, B=1000, doMethod = "all")$p.value
```


Arguments of *gof_test_disc*:

-  x: vector with counts. Should have a number for each value in vals, possibly 0.

-  pnull:  cumulative distribution function. One argument, a vector of parameters.

-  rnull:  function to generate data from distribution. One argument, a vector of parameters.

-  vals: possible values of discrete random variable, that is all x with $P(X=x)>0$

-  phat: function of data to estimate parameter. Data is sole argument.

The estimation of the parameter(s) in the case of the chi square tests is done via the minimum chi square method. The routine uses a general function minimizer. If there are values of the parameter that are not possible this can lead to warnings. It is best to put a check into the pnull function to avoid this issue. As an example the function pnull above checks that the success probability p is in the interval $(0.1)$.

### Histogram Data

A variant of discrete data sometimes encountered is data given in the form of a histogram, that is as a set of bins and their counts. The main distinction is that discrete data has specific values, for example the non-negative integers for a Poisson distribution, whereas histogram data has ranges of numbers, the bins. It turns out that, though, that the only method that requires actual values is Wassp1, and for that method one can use the midpoint of the intervals.

As an example consider the following case: we have histogram data and we want to test whether it comes from an exponential rate 1 distribution, truncated to the interval 0-2:

```{r}
rnull = function() {
  y = rexp(2500, 1) # Exp(1) data
  y = y[y<2][1:1500] # 1500 events on 0-2
  bins = 0:40/20 # binning
  hist(y, bins, plot=FALSE)$counts # find bin counts
}
x = rnull()
bins = 0:40/20
vals = (bins[-1]+bins[-21])/2
pnull = function() {
   bins = 1:40/20
   pexp(bins, 1)/pexp(2, 1)
}
  
gof_test_disc(x, pnull, rnull, vals, doMethod = "all")$p.value
```

### Continuous Data

#### Simple Hypothesis

```{r}
pnull = function(x) pnorm(x)
qnull = function(x) qnorm(x)
rnull = function()  rnorm(1000)
```

-  **Null Hypothesis is true**

```{r}
x = rnorm(1000)
gof_test_cont(x, pnull, rnull, qnull, B=1000, doMethod = "all")$p.value
```

-  **Null Hypothesis is false**

```{r}
x = rnorm(1000, 0.5) 
gof_test_cont(x, pnull, rnull, qnull, B=1000, doMethod = "all")$p.value
```

Arguments of *gof_test_cont*:

-  x: data set

-  pnull:  function to find cdf. Function has one argument, points where cdf is to be evaluated.

-  rnull:  function to generate data from density. Function has no argument.

-  qnull: quantile function. Function has one argument, points where inverse cdf is to be evaluated. If missing Wassp1 method is not used.

#### Composite Hypothesis - One Parameter

```{r}
pnull = function(x, p=0) pnorm(x, p)
qnull = function(x, p=0) qnorm(x, p)
rnull = function(p)  rnorm(1000, p)
phat = function(x) mean(x)
```

-  **Null Hypothesis is true**

```{r}
x = rnorm(1000) 
gof_test_cont(x, pnull, rnull, qnull, phat=phat, B=1000, doMethod = "all")$p.value
```


-  **Null Hypothesis is true**

```{r}
x = rnorm(1000, 0.5) 
gof_test_cont(x, pnull, rnull, qnull, phat=phat)$p.value
```

-  **Null Hypothesis is false**

```{r}
x = rnorm(1000, 0.5, 2) 
gof_test_cont(x, pnull, rnull, qnull, phat=phat, B=1000, doMethod = "all")$p.value
```

Arguments:

-  x: data set

-  pnull:  function to find cdf. First argument is points to evaluate function, second argument is parameters.

-  rnull:  function to generate data from density. Sole argument is vector of parameters. 

-  qnull: quantile function. Arguments are same as pnull.

-  phat: function to estimate the parameter 

#### Composite Hypothesis - Multiple Parameters

```{r}
pnull = function(x, p=c(0, 1)) pnorm(x, p[1], ifelse(p[2]>0, p[2], 0.001))
qnull = function(x, p=c(0, 1)) qnorm(x, p[1], ifelse(p[2]>0, p[2], 0.001))
rnull = function(p=c(0, 1))  rnorm(1000, p[1], ifelse(p[2]>0, p[2], 0.001))
phat = function(x) c(mean(x), sd(x))
```

-  **Null Hypothesis is true**

```{r}
x = rnorm(1000) 
gof_test_cont(x, pnull, rnull, qnull, phat=phat, B=1000, doMethod = "all")$p.value
```


-  **Null Hypothesis is true**

```{r}
x = rnorm(1000, 0.5) 
gof_test_cont(x, pnull, rnull, qnull, phat=phat, B=1000, doMethod = "all")$p.value
```

-  **Null Hypothesis is true**

```{r}
x = rnorm(1000, 0.5, 2) 
gof_test_cont(x, pnull, rnull, qnull, phat=phat, B=1000, doMethod = "all")$p.value
```

-  **Null Hypothesis is false**

```{r}
x = rt(1000, 2) 
gof_test_cont(x, pnull, rnull, qnull, phat=phat, B=1000, doMethod = "all")$p.value
```

Arguments: Same as for a single parameter.


## Power Estimation

### Discrete Data/Model

#### Simple Null Hypothesis

```{r}
vals = 0:10
pnull = function() pbinom(0:10, 10, 0.5)
rnull =function () table(c(0:10, rbinom(100, 10, 0.5)))-1
ralt =function (p) table(c(0:10, rbinom(100, 10, p)))-1
P=gof_power_disc(pnull, rnull, vals, ralt, 
  param_alt=seq(0.5, 0.6, 0.01),  B=c(500, 500), nbins=c(11, 5))
plot_power(P, "p", Smooth=FALSE)
```

In all cases the arguments vals, pnull and rnull are the same as for the testing routines. In addition we now have

-  ralt:  a routine with one parameter that generates data under some alternative hypothesis.

- param_alt: values to be passed to ralt. This allows the calculation of the power for many different values.

-  B=c(1000, 1000) the first number is the number of simulation runs for power estimation and the second the number of runs to be used to find the null distribution.

#### Composite Null Hypothesis

```{r}
vals = 0:10
pnull = function(p) pbinom(0:10, 10, p)
rnull = function (p) table(c(0:10, rbinom(100, 10, p)))-1
phat = function(x) sum(0:10*x)/1000
```

-  **Null Hypothesis is true**

```{r}
ralt =function (p) table(c(0:10, rbinom(100, 10, p)))-1
gof_power_disc(pnull, rnull, vals, ralt, c(0.5, 0.6), phat,
        B=c(100, 200), nbins=c(11, 5), maxProcessors = 2)

```

Note that power estimation in the case of a composite hypothesis (aka with parameters estimated) is much slower than the simple hypothesis case.

-  **Null Hypothesis is false**

```{r}
ralt =function (p) table(c(rep(0:10, 2), rbinom(100, 10, p)))
gof_power_disc(pnull, rnull, vals, ralt, 0.5, phat,
        B=c(100, 200), nbins=c(11, 5), maxProcessors = 2)
```


### Continuous Data/Model

#### Simple Null Hypothesis

```{r}
pnull = function(x) pnorm(x)
qnull = function(x) qnorm(x)
rnull = function() rnorm(100)
ralt = function(mu=0) rnorm(100, mu)
gof_power_cont(pnull, rnull, qnull, ralt, c(0, 1), B=c(100, 200))
```

#### Composite Null Hypothesis

```{r}
pnull = function(x, p=c(0,1)) pnorm(x, p[1], ifelse(p[2]>0, p[2], 0.01))
qnull = function(x, p=c(0,1)) qnorm(x, p[1], ifelse(p[2]>0, p[2], 0.01))
rnull = function(p=c(0,1)) rnorm(500, p[1], p[2])
ralt = function(mu=0) rnorm(100, mu)
phat = function(x) c(mean(x), sd(x))
gof_power_cont(pnull, rnull, qnull, ralt, c(0, 1), phat, B=c(100, 200),
               maxProcessor=2)
```

```{r}
ralt = function(df=1) {
# t distribution truncated at +- 5  
  x=rt(1000, df)
  x=x[abs(x)<5]
  x[1:100]
}  
gof_power_cont(pnull, rnull, qnull, ralt, c(2, 50), phat, Range=c(-5,5), B=c(100, 200), maxProcessor=2)
```

### Running other tests

Its is very easy for a user to add other goodness-of-fit tests to the package. This can be done by editing the routines *TS_cont** and/or **TS_disc**, which are located in the folder *examples* in the Rgod library folder. Or a user can write their own version of these files.

As an example let's say we want to run a test based on a variation of the Cramer vonMises test, namely 

$$\int_{-\infty}^{\infty} \vert F(x) - \hat{F}(x) \vert dF(x)$$
first we create a routine to calculated this test statistic:

```{r}
cvm.abs = function(x, p, nm=0, vals) {
   z=sum(abs( (1:length(x))/length(x)-p)*diff(c(0,p)) )
   names(z) = "CvM abs"
   z
}
```

This routine has to have four arguments x, p, nm and vals, just like TS_disc. Also, the output vector has to have names.

Now we can run

```{r}
vals=0:10
pnull = function() pbinom(0:10, 10, 0.5)
rnull = function() table(c(0:10, rbinom(1000, 10, 0.5)))-1
x = rnull()
gof_test_disc(x, pnull, rnull, vals, TS=cvm.abs, doMethod="all")
```

# References 